<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Stripe\Api\Model;

class V1SubscriptionSchedulesPostBody
{
    /**
     * Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay the underlying subscription at the end of each billing cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically` on creation.
     *
     * @var string
     */
    protected $billing;
    /**
     * Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
     *
     * @var mixed
     */
    protected $billingThresholds;
    /**
     * The identifier of the customer to create the subscription schedule for.
     *
     * @var string
     */
    protected $customer;
    /**
     * Specifies which fields in the response should be expanded.
     *
     * @var string[]
     */
    protected $expand;
    /**
     * Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's plan(s), set to auto-renew using the subscription's interval. Other parameters cannot be set since their values will be inferred from the subscription.
     *
     * @var string
     */
    protected $fromSubscription;
    /**
     * All invoices will be billed using the specified settings.
     *
     * @var V1SubscriptionSchedulesPostBodyInvoiceSettings
     */
    protected $invoiceSettings;
    /**
     * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     *
     * @var mixed
     */
    protected $metadata;
    /**
     * List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
     *
     * @var V1SubscriptionSchedulesPostBodyPhasesItem[]
     */
    protected $phases;
    /**
     * Configures how the subscription schedule behaves when it ends. Possible values are `none`, `renew`, or `release`. `renew` will create a new subscription schedule revision by adding a new phase using the most recent phase's `plans` applied to a duration set by `renewal_interval`. `none` will stop the subscription schedule and cancel the underlying subscription. `release` will stop the subscription schedule, but keep the underlying subscription running.
     *
     * @var string
     */
    protected $renewalBehavior;
    /**
     * Configuration for renewing the subscription schedule when it ends. Must be set if `renewal_behavior` is `renew`. Otherwise, must not be set.
     *
     * @var V1SubscriptionSchedulesPostBodyRenewalInterval
     */
    protected $renewalInterval;
    /**
     * The date at which the subscription schedule starts.
     *
     * @var string
     */
    protected $startDate;

    /**
     * Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay the underlying subscription at the end of each billing cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically` on creation.
     *
     * @return string
     */
    public function getBilling(): ?string
    {
        return $this->billing;
    }

    /**
     * Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay the underlying subscription at the end of each billing cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically` on creation.
     *
     * @param string $billing
     *
     * @return self
     */
    public function setBilling(?string $billing): self
    {
        $this->billing = $billing;

        return $this;
    }

    /**
     * Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
     *
     * @return mixed
     */
    public function getBillingThresholds()
    {
        return $this->billingThresholds;
    }

    /**
     * Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
     *
     * @param mixed $billingThresholds
     *
     * @return self
     */
    public function setBillingThresholds($billingThresholds): self
    {
        $this->billingThresholds = $billingThresholds;

        return $this;
    }

    /**
     * The identifier of the customer to create the subscription schedule for.
     *
     * @return string
     */
    public function getCustomer(): ?string
    {
        return $this->customer;
    }

    /**
     * The identifier of the customer to create the subscription schedule for.
     *
     * @param string $customer
     *
     * @return self
     */
    public function setCustomer(?string $customer): self
    {
        $this->customer = $customer;

        return $this;
    }

    /**
     * Specifies which fields in the response should be expanded.
     *
     * @return string[]
     */
    public function getExpand(): ?array
    {
        return $this->expand;
    }

    /**
     * Specifies which fields in the response should be expanded.
     *
     * @param string[] $expand
     *
     * @return self
     */
    public function setExpand(?array $expand): self
    {
        $this->expand = $expand;

        return $this;
    }

    /**
     * Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's plan(s), set to auto-renew using the subscription's interval. Other parameters cannot be set since their values will be inferred from the subscription.
     *
     * @return string
     */
    public function getFromSubscription(): ?string
    {
        return $this->fromSubscription;
    }

    /**
     * Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's plan(s), set to auto-renew using the subscription's interval. Other parameters cannot be set since their values will be inferred from the subscription.
     *
     * @param string $fromSubscription
     *
     * @return self
     */
    public function setFromSubscription(?string $fromSubscription): self
    {
        $this->fromSubscription = $fromSubscription;

        return $this;
    }

    /**
     * All invoices will be billed using the specified settings.
     *
     * @return V1SubscriptionSchedulesPostBodyInvoiceSettings
     */
    public function getInvoiceSettings(): ?V1SubscriptionSchedulesPostBodyInvoiceSettings
    {
        return $this->invoiceSettings;
    }

    /**
     * All invoices will be billed using the specified settings.
     *
     * @param V1SubscriptionSchedulesPostBodyInvoiceSettings $invoiceSettings
     *
     * @return self
     */
    public function setInvoiceSettings(?V1SubscriptionSchedulesPostBodyInvoiceSettings $invoiceSettings): self
    {
        $this->invoiceSettings = $invoiceSettings;

        return $this;
    }

    /**
     * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     *
     * @return mixed
     */
    public function getMetadata()
    {
        return $this->metadata;
    }

    /**
     * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     *
     * @param mixed $metadata
     *
     * @return self
     */
    public function setMetadata($metadata): self
    {
        $this->metadata = $metadata;

        return $this;
    }

    /**
     * List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
     *
     * @return V1SubscriptionSchedulesPostBodyPhasesItem[]
     */
    public function getPhases(): ?array
    {
        return $this->phases;
    }

    /**
     * List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
     *
     * @param V1SubscriptionSchedulesPostBodyPhasesItem[] $phases
     *
     * @return self
     */
    public function setPhases(?array $phases): self
    {
        $this->phases = $phases;

        return $this;
    }

    /**
     * Configures how the subscription schedule behaves when it ends. Possible values are `none`, `renew`, or `release`. `renew` will create a new subscription schedule revision by adding a new phase using the most recent phase's `plans` applied to a duration set by `renewal_interval`. `none` will stop the subscription schedule and cancel the underlying subscription. `release` will stop the subscription schedule, but keep the underlying subscription running.
     *
     * @return string
     */
    public function getRenewalBehavior(): ?string
    {
        return $this->renewalBehavior;
    }

    /**
     * Configures how the subscription schedule behaves when it ends. Possible values are `none`, `renew`, or `release`. `renew` will create a new subscription schedule revision by adding a new phase using the most recent phase's `plans` applied to a duration set by `renewal_interval`. `none` will stop the subscription schedule and cancel the underlying subscription. `release` will stop the subscription schedule, but keep the underlying subscription running.
     *
     * @param string $renewalBehavior
     *
     * @return self
     */
    public function setRenewalBehavior(?string $renewalBehavior): self
    {
        $this->renewalBehavior = $renewalBehavior;

        return $this;
    }

    /**
     * Configuration for renewing the subscription schedule when it ends. Must be set if `renewal_behavior` is `renew`. Otherwise, must not be set.
     *
     * @return V1SubscriptionSchedulesPostBodyRenewalInterval
     */
    public function getRenewalInterval(): ?V1SubscriptionSchedulesPostBodyRenewalInterval
    {
        return $this->renewalInterval;
    }

    /**
     * Configuration for renewing the subscription schedule when it ends. Must be set if `renewal_behavior` is `renew`. Otherwise, must not be set.
     *
     * @param V1SubscriptionSchedulesPostBodyRenewalInterval $renewalInterval
     *
     * @return self
     */
    public function setRenewalInterval(?V1SubscriptionSchedulesPostBodyRenewalInterval $renewalInterval): self
    {
        $this->renewalInterval = $renewalInterval;

        return $this;
    }

    /**
     * The date at which the subscription schedule starts.
     *
     * @return string
     */
    public function getStartDate(): ?string
    {
        return $this->startDate;
    }

    /**
     * The date at which the subscription schedule starts.
     *
     * @param string $startDate
     *
     * @return self
     */
    public function setStartDate(?string $startDate): self
    {
        $this->startDate = $startDate;

        return $this;
    }
}
